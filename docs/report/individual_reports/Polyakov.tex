Для упрощения разобьем задачу, на подзадачи

\begin{enumerate}
\item определить места хранения переписки пользователя;
\item определить формат хранения переписки;
\item разработать парсер для каждого из возможных форматов;
\item выделить важную информацию их каждой записи;
\item автоматизировать процесс поиска журнальных файлов;
\item производить сохранение полученных информации формат XML.
\end{enumerate}

\subsection{Определить формат хранения переписки}

Приложение «skype» хранит переписку локально на машинах пользователей или же возможна синхронизация с машин других пользователей \cite{skypechat}. Формат хранения SQLite. 

По умолчанию файлы распологаются в каталоге: “WINDOWS\_DRIVE”/Users/”USER\_NAME”/AppData/Roaming/Skype/”USER\_SKYPE\_NAME”

Основная интересующая нас информация находится в main.db.

main.db  содержит 18 таблиц:

\begin{itemize} 
\item"DbMeta"
\item"Contacts"
\item"LegacyMessages"
\item"Calls"
\item"Accounts"
\item"Transfers"
\item"Voicemails"
\item"Chats"
\item"Messages"   
\item"ContactGroups"
\item"Videos"
\item"SMSes"
\item"CallMembers"
\item"ChatMembers"
\item"Alerts"
\item"Conversations"
\item"Participants"
\item"VideoMessages"
\end{itemize}

Таблицы которые нам интересны, на данный момент:    

\begin{itemize}
\item"Contacts"
\item"Messages"
\item"Chats" 
\end{itemize}

Приложение «pidgin» хранит лог файлы локально на машине пользователя в формате HTML и TXT. По умолчанию лог файли хранятся в .HTML файле. Настройки программы и подключенных аккаунтов в XML, но особой ценности на данный момент не представляют.
По умолчанию файлы распологаются в каталоге: “WINDOWS\_DRIVE”/Users/”USER\_WIN\_NAME”/AppData/Roaming/.purple/logs/”USER\_PIDGIN\_NAME”
Основная интересующая нас информация хранится в файлах с такой маской имени YEAR-MONTH-DATE.TIME.html пример:2013-03-02.004915+0700NOVT.htm

\subsection{Определить места хранения переписки пользователя}

Определение месторасположения файлов переписки происходит следующим образом. Для при монтированному образу запускается модуль который сужает область поиска, сканируя только нужные места в образе (к примеру не всю папку \%ProrgamFiles, а только \%ProrgamFiles/Skype). Сканированием папки занимается класс QDirIterator. После вызова происходит поочередный обход по каждому файлу в директории и под директории. Проверка полученного имени файла  осуществляется по маске, если реакция на маску положительная, происходит добавление в список обрабатываемых файлов. 


\subsection{Парсинг найденых файлов}

В зависимости от обрабатываемых логов, запускается нужный модуль. Из полученного ранее списка, найденные файлы поочередно открываются и парсятся. Методами класса QstringList происходит резанье строк и добавление в список. Для парсинга полученного списка используется регулярные вырожения использующие класс QRegExp. 

\subsection{Сохранение полученного в XML}

Соранение полученных данных происходит в ранее выбраный формат XML. Для этого используется класс QXmlStreamReader и QxmlStreamWriter.
Класс QXmlStreamWriter представляет XML писателя с простым потоковым API.

QXmlStreamWriter работает в связке с QXmlStreamReader для записи XML. Как и связанный класс, он работает с QIODevice, определённым с помощью setDevice ().

Класс QXmlStreamReader представляет собой быстрый синтаксически корректный XML анализатор с простым потоковым API.
QXmlStreamReader является быстрым и более удобным для замены в Qt анализатора SAX (смотрите QXmlSimpleReader), а в некоторых случаях он даже более предпочтителен, чем использование DOM дерева (смотрите QDomDocument). QXmlStreamReader считывает данные с QIODevice (смотрите setDevice()) или с необработанного QByteArray (смотрите addData()). Вместе с QXmlStreamWriter Qt обеспечивает связанный класс для записи XML.

\subsubsection{Работа с xml-файлами}

XML - eXtensible Markup Language или расширяемый язык разметки. XML разрабатывался как язык с простым формальным синтаксисом, удобный для создания и обработки документов программами и одновременно удобный для чтения и создания документов человеком. Задумка языка в том, что он позволяет дополнять данные метаданными, которые разделяют документ на объекты с атрибутами. Это позволяет упростить программную обработку документов, так как структурирует информацию. 
